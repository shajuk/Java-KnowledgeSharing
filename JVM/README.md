## JVM Architecture

In this tutorial we will see how a java program executes (high level) with various components of JVM.

Once you write any java program in .java file that is called Java source file. Java source file converted to Class file (.class) file by compiler using javac command. This Class file given as input to JVM which is responsible to load and execute this class file.    

<img alt=".class file generation" src="https://github.com/shajuk/Java-KnowledgeSharing/blob/master/JVM/java%20compilation.jpg" width="560"/>

Further this class file acts as input to class loader sub-system. This sub-system is responsible for loading, linking and initialization of classes. To load/execute some memory must be required. The Cass file dumped into memory area (method area) which further communicates to execution engine. Memory areas communicate with class loader sub-system. Immediately after loading verification process starts in which byte code verifier verifies whether generated byte code is proper or not,  means generated by valid compiler or not (or is it a virus). After this Prepare process starts. In this process, for static variable memory is allocated and assigned with default values (whereas original values for static variables are stored during initialization process). Then in resolve process all symbolic references are replaced with original references from method area. After this initialization starts which assigns original values to static variables and static blocks executed. After initialization class loading completed successfully by class loader sub-system. Further, execution engine is responsible to execute the program. During executing java program execution engine may require native libraries. These native method libraries are provide by Java Native Interface (JNI)

<img alt="JVM Architecture" src="https://github.com/shajuk/Java-KnowledgeSharing/blob/master/JVM/JVM%20Architecture.jpg" width="560"/>

Various <b>memory areas</b> present inside JVM are:

<ol>
	<li>
		<b>Method area</b> – contains class level data (Static variables / blocks etc). This method area is shared among all Java Virtual Machine threads.
	</li>
	<li>
		<b>Heap area</b> – by default object level data will be saved (object and corresponding instance variables, arrays etc).  There is only one heap inside a Java virtual machine instance, all threads share it.
	</li>
	<li>
		<b>Stack area</b> – All local variable will be stored in corresponding runtime stack. For every thread a separate runtime stack will be created. Each and every method called by thread will be stored in corresponding Stack including local variables. Each entry in stack called stack frame which contains local variable array, Operand stack, frame data and Reference to runtime constant pool for class of the current method.
	</li>
	<li>
		<b>PC Register</b> – Holds address of current executing instruction. If the current executing method is ‘native’, then the value of program counter register will be undefined. For every thread a separate PC registers will be created.
	</li>
	<li>
		<b>Native method Stacks</b> – Holds native method information. For every thread a separate stack will be created.
	</li>
</ol>