## JVM Architecture

In this tutorial we will see how a java program executes (high level) with various components of JVM.

Once you write any java program in .java file that is called Java source file. Java source file converted to Class file (.class) file by compiler using javac command. This Class file given as input to JVM which is responsible to load and execute this class file.    

<img alt=".class file generation" src="https://github.com/shajuk/Java-KnowledgeSharing/blob/master/JVM/java%20compilation.jpg" width="560"/>

Further this class file acts as input to class loader sub-system. This sub-system is responsible for loading, linking and initialization of classes. To load/execute some memory must be required. The Cass file dumped into memory area (method area) which further communicates to execution engine. Memory areas communicate with class loader sub-system. Immediately after loading verification process starts in which byte code verifier verifies whether generated byte code is proper or not,  means generated by valid compiler or not (or is it a virus). After this Prepare process starts. In this process, for static variable memory is allocated and assigned with default values (whereas original values for static variables are stored during initialization process). Then in resolve process all symbolic references are replaced with original references from method area. After this initialization starts which assigns original values to static variables and static blocks executed. After initialization class loading completed successfully by class loader sub-system. Further, execution engine is responsible to execute the program. During executing java program execution engine may require native libraries. These native method libraries are provide by Java Native Interface (JNI)

<img alt="JVM Architecture" src="https://github.com/shajuk/Java-KnowledgeSharing/blob/master/JVM/JVM%20Architecture.jpg" width="560"/>

Various <b>memory areas</b> present inside JVM are:

<ol>
	<li>
		<b>Method area</b> – contains class level data (Static variables / blocks etc). This method area is shared among all Java Virtual Machine threads.
	</li>
	<li>
		<b>Heap area</b> – by default object level data will be saved (object and corresponding instance variables, arrays etc).  There is only one heap inside a Java virtual machine instance, all threads share it.
	</li>
	<li>
		<b>Stack area</b> – All local variable will be stored in corresponding runtime stack. For every thread a separate runtime stack will be created. Each and every method called by thread will be stored in corresponding Stack including local variables. Each entry in stack called stack frame which contains local variable array, Operand stack, frame data and Reference to runtime constant pool for class of the current method.
	</li>
	<li>
		<b>PC Register</b> – Holds address of current executing instruction. If the current executing method is ‘native’, then the value of program counter register will be undefined. For every thread a separate PC registers will be created.
	</li>
	<li>
		<b>Native method Stacks</b> – Holds native method information. For every thread a separate stack will be created.
	</li>
</ol>

Following are component of JVM:

<ol>
	<li>
		<b><u>Class Loader sub-system:</u></b>
		Class loader reads byte code and create the instance of java.lang.class , It performs three main functions of JVM, namely: loading, linking and initialization
		<ol type="i">
			<li>
				Loading : Java ClassLoader loads a java class file into java virtual machine. For this Class loader sub-system follows delegation hierarchy algoritm and uses following class loaders :
				<ol type="a">
					<li>
						Bootstrap class loader – load classes from boot strap class path (JRE/lib/rt.jar). All core java API classes are taken care by boot strap class loader
					</li>
					<li>
						Extension class loader – classes present inside ext folder (JRE/lib/ext) are taken care by extension class loader
					</li>
					<li>
						Application class loader – responsible to load classes from application level class path (environment variables class path, Manifest)
					</li>
				</ol>
				Among the class loader boot strap class loader gets highest priority. If boot strap class loader is unable to load the class then this responsibility will be taken care by extension class loader. If extension class loader fails to load the class the application class loader loads the class.
			</li>
			<li>
				 Linking : Linking process consists of three sub tasks
				 <ol type="a">
					<li>
						Verify
					</li>
					<li>
						Prepare
					</li>
					<li>
						Resolve
					</li>
				</ol>
			</li>
			<li>
				Initialization – class variables are given their proper initial values first loading happens then Linking and then Initialization
			</li>
		</ol>
	</li>
	<li>
		 <b><u>Byte code verifier:</u></b>
		It verifies whether generated byte code is proper or not. Byte code verifier is crucial component for security.
	</li>
	<li>
		 <b><u>Execution Engine:</u></b>
		It is central component of JVM. Improve performance of the system in case of calling same method again and again. It is responsible to execute program line by line. It has two parts
		<ol>
			<li>
				Interpreter - "Interpreted" means that the computer looks at the language, and then turns it into native machine language. Interpretation happens at runtime.
			</li>
			<li>
				JIT complier – Just-in-time (JIT) compiler is a program that turns Java bytecode (a program that contains instructions that must be interpreted) into instructions that can be sent directly to the processor. It has following parts :
				<ol type="a">
					<li>
						Intermediate code generator – produces intermediate code
					</li>
					<li>
						Code optimizer – responsible to optimize the code
					</li>
					<li>
						Target Code Generator – responsible to generate machine code or native code
					</li>
				</ol>
				In JIT compiler there is a component called profiler which is responsible for hotspots.
			</li>
		</ol>
	</li>
	<li>
		<b>Garbage collector:</b> Garbage collection is the process of automatically freeing objects that are no longer referenced by the program. It periodically checks for the object on heap, whose link is broken so it can collect garbage from heap.
	</li>
	<li>
		<b>Security manager:</b> Constantly monitors the code. It is special java object that is responsible for guarding security policies for java applications. It is always consulted before any potentially dangerous operation is requested by a java application.
	</li>
</ol>
